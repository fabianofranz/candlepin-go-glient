/*
 * Candlepin
 *
 * Candlepin is subscription management server written in Java. It helps with management of software subscriptions.
 *
 * API version: 2.3.10
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type HypervisorsApiService service

/*
HypervisorsApiService hypervisorUpdate
Updates the list of Hypervisor Guests Allows agents such as virt-who to update its host list and associate the guests for each host. This is typically used when a host is unable to register to candlepin via subscription manager.  In situations where consumers already exist it is probably best not to allow creation of new hypervisor consumers.  Most consumers do not have a hypervisorId attribute, so that should be added manually when necessary by the management environment. @deprecated Use the asynchronous method
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HypervisorUpdateOpts - Optional Parameters:
 * @param "Owner" (optional.String) - 
 * @param "CreateMissing" (optional.Bool) -  specify whether or not to create missing hypervisors.Default is true.  If false is specified, hypervisorIds that are not foundwill result in failed entries in the resulting HypervisorCheckInResult
 * @param "RequestBody" (optional.Interface of map[string][]GuestIdDto) - 
@return HypervisorCheckInResult
*/

type HypervisorUpdateOpts struct {
	Owner optional.String
	CreateMissing optional.Bool
	RequestBody optional.Interface
}

func (a *HypervisorsApiService) HypervisorUpdate(ctx context.Context, localVarOptionals *HypervisorUpdateOpts) (HypervisorCheckInResult, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  HypervisorCheckInResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/hypervisors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Owner.IsSet() {
		localVarQueryParams.Add("owner", parameterToString(localVarOptionals.Owner.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateMissing.IsSet() {
		localVarQueryParams.Add("create_missing", parameterToString(localVarOptionals.CreateMissing.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.RequestBody.IsSet() {
		localVarOptionalRequestBody, localVarOptionalRequestBodyok := localVarOptionals.RequestBody.Value().(map[string][]GuestIdDto)
		if !localVarOptionalRequestBodyok {
			return localVarReturnValue, nil, reportError("requestBody should be map[string][]GuestIdDto")
		}
		localVarPostBody = &localVarOptionalRequestBody
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v HypervisorCheckInResult
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
HypervisorsApiService hypervisorUpdateAsync
Creates or Updates the list of Hypervisor hosts Allows agents such as virt-who to update hosts&#39; information . This is typically used when a host is unable to register to candlepin via subscription manager. In situations where consumers already exist it is probably best not to allow creation of new hypervisor consumers.  Most consumers do not have a hypervisorId attribute, so that should be added manually when necessary by the management environment. Default is true.  If false is specified, hypervisorIds that are not found will result in a failed state of the job.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param owner
 * @param optional nil or *HypervisorUpdateAsyncOpts - Optional Parameters:
 * @param "CreateMissing" (optional.Bool) -  specify whether or not to create missing hypervisors.Default is true.  If false is specified, hypervisorIds that are not foundwill result in failed entries in the resulting HypervisorCheckInResult
 * @param "ReporterId" (optional.String) - 
 * @param "Body" (optional.String) - 
@return JobDetail
*/

type HypervisorUpdateAsyncOpts struct {
	CreateMissing optional.Bool
	ReporterId optional.String
	Body optional.String
}

func (a *HypervisorsApiService) HypervisorUpdateAsync(ctx context.Context, owner string, localVarOptionals *HypervisorUpdateAsyncOpts) (JobDetail, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  JobDetail
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/hypervisors/{owner}"
	localVarPath = strings.Replace(localVarPath, "{"+"owner"+"}", fmt.Sprintf("%v", owner), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CreateMissing.IsSet() {
		localVarQueryParams.Add("create_missing", parameterToString(localVarOptionals.CreateMissing.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReporterId.IsSet() {
		localVarQueryParams.Add("reporter_id", parameterToString(localVarOptionals.ReporterId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobDetail
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
